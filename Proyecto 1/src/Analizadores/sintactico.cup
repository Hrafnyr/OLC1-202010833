package Analizadores;
import java_cup.runtime.Symbol;

//java -jar java-cup-11b.jar -parser A_sintactico -symbols Simbolos sintactico.cup
//identacion python probar con contador de sentencias 
parser code 
{:
    //Variable que guarda el código python
    public String txtPython = "";
    String auxP = "";
    String aux2="";
    String tmpPS = "";
    String tmp = "";
    int cont1 = 0;

    //Método al que se llama automáticamente ante algún error sintactico. 
    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
            claseErrores datos = new claseErrores(String.valueOf(s.value), "Error sintáctico", "eliminar entrada incorrecta",s.left,s.right);
            Analizador_Lexico.TError.add(datos);
    } 
    
    //Método al que se llama en el momento en que ya no es posible una recuperación de errores. 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
            claseErrores datos = new claseErrores("Null", "Error sintáctico", "eliminar entrada incorrecta",s.left,s.right);
            Analizador_Lexico.TError.add(datos);
    }
:} 



//FALTA LIMPIAR TEXTO Y ELIMINAR SYSTEM.OUT.PRINT...

//Terminales
terminal Cadena;
terminal digitoEntero;
terminal digitoDecimal;
terminal caracter;
terminal caracterAS;
terminal Rtrue;
terminal Rfalse;
terminal abrir_cor;
terminal cerrar_cor;
terminal Rnumero;
terminal Rcadena;
terminal Rboolean;
terminal Rcaracter;
terminal mas;
terminal resta;
terminal mult;
terminal div;
terminal Rpotencia;
terminal Rmod;
terminal abrir_par;
terminal cerrar_par;
terminal aitr;
terminal citr;
terminal puntoComa;
terminal Coma;
terminal mayor;
terminal menor;
terminal mayorIgual;
terminal menorIgual;
terminal igual;
terminal diferente;
terminal or;
terminal and;
terminal not;
terminal inicio;
terminal fin;
terminal Ringresar;
terminal id;
terminal Rcomo;
terminal RCon_valor;
terminal asignacion;
terminal condSi;
terminal contrario;
terminal finSi;
terminal OSi;
terminal segun;
terminal hacer;
terminal entonces;
terminal finSegun;
terminal para;
terminal hasta;
terminal incremento;
terminal finPara;
terminal mientras;
terminal finMientras;
terminal repetir;
terminal hastaQue;
terminal retornar;
terminal metodo;
terminal Finmetodo;
terminal con_parametros;
terminal funcion;
terminal Finfuncion;
terminal ejecutar;
terminal imprimir;
terminal imprimir_nl;

//No terminales
non terminal cuerpo,INICIO, ASIGNACION,DECLARACION, EXPRESION, TIPODATO;
non terminal LISTA, CONDICIONALES;
non terminal IF, CONDICION, INSTRUCCIONES, BLOQUE;
non terminal SEGUN, CASE;
non terminal PARA;
non terminal MIENTRAS,REPETIR;
non terminal RETORNO, IMPRESION;
non terminal METODO, LISTAP, FUNCION, LLAMADA;
non terminal OP, OPL;
non terminal LEJC;
non terminal auxFS;

//gramaticas
start with INICIO;

INICIO::= inicio {:txtPython+="def main():\n    ";:} cuerpo fin {:txtPython+="if __name__ == '__main__':\n    main()";System.out.println(txtPython);:}
;

cuerpo::= DECLARACION 
    | ASIGNACION 
    | CONDICIONALES
    | RETORNO
    | METODO
    | FUNCION
    | LLAMADA
    | IMPRESION
    | cuerpo CONDICIONALES
    | cuerpo DECLARACION 
    | cuerpo ASIGNACION 
    | cuerpo RETORNO
    | cuerpo METODO
    | cuerpo FUNCION
    | cuerpo LLAMADA
    | cuerpo IMPRESION
    | error puntoComa {:System.out.println("Se espera punto y coma");:}
    | error asignacion {:System.out.println("Se espera ->");:}
    | error Coma {:System.out.println("Se espera coma");:}
;

LLAMADA::= ejecutar id:idd abrir_par cerrar_par puntoComa
            {:txtPython+= String.valueOf(idd)+"()\n"; System.out.println(txtPython);:}
    | ejecutar id:idd abrir_par LEJC cerrar_par puntoComa
    {:txtPython+= String.valueOf(idd)+"("+aux2+")\n"; System.out.println(txtPython); auxP=""; aux2="";:}
;

METODO::= metodo id:idd {:txtPython+="def "+String.valueOf(idd)+"\n    "; System.out.println(txtPython); auxP="";:} INSTRUCCIONES Finmetodo
        | metodo id:idd con_parametros abrir_par LISTAP cerrar_par {:txtPython+="def "+String.valueOf(idd)+"("+auxP+")\n    "; System.out.println(txtPython); auxP="";:} INSTRUCCIONES Finmetodo
;

FUNCION::= funcion id:idd TIPODATO {:txtPython+="def "+String.valueOf(idd)+"\n    "; System.out.println(txtPython); auxP="";:} INSTRUCCIONES Finfuncion
        | funcion id:idd TIPODATO con_parametros abrir_par LISTAP cerrar_par {:txtPython+="def "+String.valueOf(idd)+"("+auxP+")\n    "; System.out.println(txtPython); auxP="";:} INSTRUCCIONES  Finfuncion 
;

IMPRESION::= imprimir CONDICION:b puntoComa 
            {:txtPython+="print("+auxP+")\n"; System.out.println(txtPython);auxP="";:}
        | imprimir_nl CONDICION:b puntoComa 
            {:txtPython+="print("+auxP+"\\n)\n"; System.out.println(txtPython);auxP="";:}
;

DECLARACION::= Ringresar LISTA Rcomo TIPODATO RCon_valor CONDICION:b puntoComa
            {:txtPython+= aux2; aux2="";txtPython+=" = ";
           
            for(int i = 0 ; i <= cont1; i = i + 1)
            {
                if(i==0){
                    tmp+=auxP;
                }
                else{
                    tmp+= "," + auxP;
                }
             
            }
            ;txtPython+= tmp+"\n"; System.out.println(txtPython); auxP="";tmp="";cont1=0;:}
; 

ASIGNACION::= LISTA asignacion CONDICION:b puntoComa
            {:txtPython+= aux2; aux2="";txtPython+=" = ";
           
            for(int i = 0 ; i <= cont1; i = i + 1)
            {
                if(i==0){
                    tmp+=auxP;
                }
                else{
                    tmp+= "," + auxP;
                }
             
            }
            ;txtPython+= tmp+"\n"; System.out.println(txtPython); auxP="";tmp="";cont1=0;:}
;

LISTAP::= id:idd TIPODATO {:aux2+=String.valueOf(idd);:} 
        | LISTAP Coma id:idd  TIPODATO {:aux2+=","+String.valueOf(idd);:}
;

LISTA::= id:idd {:aux2+=idd.toString();:}
        | LISTA Coma id:idd {:aux2+=","+idd.toString();cont1=cont1+1;:}
;

LEJC::= CONDICION:b  {:aux2+=auxP;:}
        | LEJC    Coma CONDICION:b  {:aux2+=","+auxP;:}
;

CONDICIONALES::= IF
                | SEGUN
                | PARA
                | MIENTRAS
                | REPETIR
;

IF::= condSi CONDICION:b {:txtPython+="if "+auxP+": \n    "; System.out.println(txtPython); auxP="";:} auxFS
;

auxFS::= entonces INSTRUCCIONES finSi {:System.out.println(txtPython);auxP="";:}
    | INSTRUCCIONES contrario {:txtPython+="\nelse:\n    ";:} INSTRUCCIONES finSi {:System.out.println(txtPython);auxP="";:} 
    | INSTRUCCIONES BLOQUE finSi {:System.out.println(txtPython);auxP="";:} 
  
;

BLOQUE::= OSi CONDICION:b entonces {:txtPython+="\nelif "+auxP+":\n    ";:} INSTRUCCIONES
        | BLOQUE OSi CONDICION:b entonces {:txtPython+="\nelif "+auxP+":\n    ";:} INSTRUCCIONES
        | BLOQUE contrario {:txtPython+="\nelse:\n    ";:}  INSTRUCCIONES
;

PARA::= para id:idd asignacion CONDICION:b hasta CONDICION:c hacer {:txtPython="for "+String.valueOf(idd)+" in range("+auxP;auxP="";txtPython+=","+auxP+")\n\t"; System.out.println(txtPython); auxP="";:} INSTRUCCIONES finPara 
    | para id:idd asignacion CONDICION:b hasta CONDICION:c hacer finPara {:txtPython="for "+String.valueOf(idd)+" in range("+auxP;auxP="";txtPython+=","+auxP+")\n\t"; System.out.println(txtPython); auxP="";:}
    | para id:idd asignacion CONDICION:b hasta CONDICION:c incremento digitoEntero:num hacer {:txtPython="for "+String.valueOf(idd)+" in range("+auxP;auxP="";txtPython+=","+auxP+","+String.valueOf(num)+")\n\t"; System.out.println(txtPython); auxP="";:} INSTRUCCIONES finPara
    | para id:idd asignacion CONDICION:b hasta CONDICION:c incremento digitoEntero:num hacer finPara  {:txtPython="for "+String.valueOf(idd)+" in range("+auxP;auxP="";txtPython+=","+auxP+","+String.valueOf(num)+")\n\t"; System.out.println(txtPython); auxP="";:}
;

MIENTRAS::= mientras CONDICION:b hacer {:txtPython+="while "+auxP+"\n    "; System.out.println(txtPython); auxP="";:} INSTRUCCIONES finMientras
        | mientras CONDICION:b hacer finMientras {:txtPython+="while "+auxP+"\n    "; System.out.println(txtPython); auxP="";:}
;

REPETIR::= repetir INSTRUCCIONES hastaQue CONDICION:b {:txtPython+="while "+auxP+"\n    if "+String.valueOf(b)+"== False:\n         break"; System.out.println(txtPython); auxP="";:}
        | repetir hastaQue CONDICION:b {:txtPython+="while "+b+"\n    if "+auxP+"== False:\n         break"; System.out.println(txtPython); auxP="";:}
;

RETORNO::= retornar CONDICION:b puntoComa {:txtPython+="return "+auxP+"\n"; System.out.println(txtPython);:}
;

SEGUN::= segun CONDICION:b hacer {:tmpPS+=auxP; System.out.println(txtPython); auxP="";:} CASE finSegun {:tmpPS="";:}
;

CASE::= aitr CONDICION:c citr entonces {:txtPython+="if "+tmpPS+"=="+auxP+"\n    ";auxP="";:} INSTRUCCIONES 
        | CASE contrario entonces {:txtPython+="\nelse: \n    ";:} INSTRUCCIONES
        | CASE aitr CONDICION:c citr entonces {:txtPython+="elif "+tmpPS+"=="+auxP+"\n    ";auxP="";:} INSTRUCCIONES
;

//Falta operaciones aritmeticas
EXPRESION::= digitoEntero:a {:RESULT = a;:} 
    | digitoDecimal:a {:RESULT = a;:} 
    | id:a  {:RESULT = a;:} 
    | Cadena:a {:RESULT = a;:} 
    | caracter:a {:RESULT = a;:} 
    | Rtrue:a {:RESULT = a;:} 
    | Rfalse:a {:RESULT = a;:} 
    | caracterAS:a {:RESULT = a;:} 
;

//Falta codigo de traduccion para más de una expresion
CONDICION::= EXPRESION:a {:auxP+= a.toString();:} 
        | EXPRESION:a OP:opr EXPRESION:s {:auxP+=a.toString()+opr+s.toString();System.out.println(txtPython);:}
        | CONDICION OPL:oplr EXPRESION:a {:auxP+=oplr.toString()+" "+a.toString();:}  
;

//TERMINADO
OP::= mayor:oop {:RESULT=">";:}
    | menor:oop {:RESULT="<";:}
    | mayorIgual:oop {:RESULT=">=";:}
    | menorIgual:oop {:RESULT="<=";:}
    | igual:oop {:RESULT="==";:}
    | diferente:oop {:RESULT="!=";:}
;

//TERMINADO
OPL::= or:opl {:RESULT=opl;:}
    | and: opl {:RESULT=opl;:}
    | not: opl {:RESULT=opl;:}
;

//TERMINADO
INSTRUCCIONES::= DECLARACION
    | ASIGNACION
    | CONDICIONALES
    | LLAMADA
    | IMPRESION
    | RETORNO
    | INSTRUCCIONES RETORNO
    | INSTRUCCIONES DECLARACION 
    | INSTRUCCIONES ASIGNACION
    | INSTRUCCIONES CONDICIONALES
    | INSTRUCCIONES LLAMADA
    | INSTRUCCIONES IMPRESION
;

//TERMINADO
TIPODATO::= Rnumero:td {:RESULT=td;:}
            | Rcadena:td {:RESULT=td;:}
            | Rboolean:td {:RESULT=td;:}
            | Rcaracter:td {:RESULT=td;:}
;
