package Analizadores;
import java_cup.runtime.Symbol;

//java -jar java-cup-11b.jar -parser A_sintactico -symbols Simbolos sintactico.cup

parser code 
{:
    
    public static String txtPython = ""; //Variable que guarda el código python
    String auxP = ""; //Guarda condicion/expresion
    String aux2=""; //Guarda informacion de lista parametros, nombres y expresiones/condiciones
    String tmpPS = ""; //Guarda condicion del switch case
    String tmp = "";   // Guarda lista de resultados asignacion/declaracion
    String tmpPARA =""; //Guarda condicion hasta(condicion) del ciclo para
    int cont1 = 0; //contador de nombres asignacion/declaracion

    int contTPY = 0; //contador de tabulacion
    
    public static String txtGo = ""; //Variable que guarda el código Golang
    String auxTP = ""; //guarda el tipo de dato
    String auxC = "";
    String aux2G = "";
    String tmpG="";
    String auxID="";
    String tmpPARAG="";
    String imps = ""; //guarda bloque de importaciones
    int flag = 0; //verificador para cierre de llave main
    int flag2 = 0;

    //caracter ascii
    String cA = ""; //guarda el valor del token caracter Ascci
    int c = 0; //guarda el valor del caracter asccii

    //Metodo para calcular la identación correcta python
    public String tab(){
        String tab = "";
        for(int i = 0; i < (contTPY*4); i++) {
            tab+=" ";

        }
       
        return tab;
    }

    //Método al que se llama automáticamente ante algún error sintactico. 
    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
            claseErrores datos = new claseErrores(String.valueOf(s.value), "Error sintáctico", "eliminar entrada incorrecta",s.left,s.right);
            Analizador_Lexico.TError.add(datos);
    } 
    
    //Método al que se llama en el momento en que ya no es posible una recuperación de errores. 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
            claseErrores datos = new claseErrores("Null", "Error sintáctico", "eliminar entrada incorrecta",s.left,s.right);
            Analizador_Lexico.TError.add(datos);
    }
:} 

action code
{:
    String sumaO(Object v1, Object v2){
        auxP+= " "+v1.toString() + " + " + v2.toString();
        auxC+= " "+v1.toString() + " + " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
    
    String restaO(Object v1, Object v2){
        auxP+= " "+v1.toString() + " - " + v2.toString();
        auxC+= " "+v1.toString() + " - " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        flag2=0;
        return "";
    }

    String multi(Object v1, Object v2){
        auxP+= " "+v1.toString() + " * " + v2.toString();
        auxC+= " "+v1.toString() + " * " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }

    String divs(Object v1, Object v2){

        auxP+= " "+v1.toString() + " / " + v2.toString();
        auxC+= " "+v1.toString() + " / " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
    
    String modulo(Object v1, Object v2){

        auxP+= " "+v1.toString() + " % " + v2.toString();
        auxC+= " "+v1.toString() + " % " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
    
    String potencia(Object v1, Object v2){

        auxP+= " "+v1.toString() + " ** " + v2.toString();
        auxC+= " math.Pow(float64("+v1.toString() + "),float64(" + v2.toString()+"))";
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
:}

//Terminales
terminal Cadena;
terminal digitoEntero;
terminal digitoDecimal;
terminal caracter;
terminal caracterAS;
terminal Rtrue;
terminal Rfalse;
terminal abrir_cor;
terminal cerrar_cor;
terminal Rnumero;
terminal Rcadena;
terminal Rboolean;
terminal Rcaracter;
terminal mas;
terminal resta;
terminal mult;
terminal div;
terminal Rpotencia;
terminal Rmod;
terminal abrir_par;
terminal cerrar_par;
terminal aitr;
terminal citr;
terminal puntoComa;
terminal Coma;
terminal mayor;
terminal menor;
terminal mayorIgual;
terminal menorIgual;
terminal igual;
terminal diferente;
terminal or;
terminal and;
terminal not;
terminal inicio;
terminal fin;
terminal Ringresar;
terminal id;
terminal Rcomo;
terminal RCon_valor;
terminal asignacion;
terminal condSi;
terminal contrario;
terminal finSi;
terminal OSi;
terminal segun;
terminal hacer;
terminal entonces;
terminal finSegun;
terminal para;
terminal hasta;
terminal incremento;
terminal finPara;
terminal mientras;
terminal finMientras;
terminal repetir;
terminal hastaQue;
terminal retornar;
terminal metodo;
terminal Finmetodo;
terminal con_parametros;
terminal funcion;
terminal Finfuncion;
terminal ejecutar;
terminal imprimir;
terminal imprimir_nl;


//No terminales
non terminal cuerpo,INICIO, ASIGNACION,DECLARACION, EXPRESION, TIPODATO;
non terminal LISTA, CONDICIONALES;
non terminal IF, CONDICION, INSTRUCCIONES, BLOQUE;
non terminal SEGUN, CASE;
non terminal PARA,BLOQUEPARA;
non terminal MIENTRAS,REPETIR;
non terminal RETORNO, IMPRESION;
non terminal METODO, LISTAP, FUNCION, LLAMADA;
non terminal OP, OPL;
non terminal LEJC;
non terminal auxFS;
non terminal OP1, OP2,OP3;
non terminal OPERACIONES;


//gramaticas
start with INICIO;

INICIO::= inicio 
    {: 
        txtPython+=tab()+"def main():\n";
        imps+= "import (\n\"fmt\"\n )\n";
        txtGo+=tab()+"package main\n"+tab()+imps+"func main(){\n";
        contTPY+=1;
    :} cuerpo fin 
    {:
        txtPython+="if __name__ == '__main__':\n    main()";
        
        if(flag==0){
            txtGo+="}";
        }

        contTPY-=1;
        imps = "";
        System.out.println(txtPython);
        System.out.println(txtGo);
    :}
    | error fin {:System.out.println("Falta inicio");:}
;

cuerpo::= DECLARACION 
    | ASIGNACION 
    | CONDICIONALES
    | RETORNO
    | METODO
    | FUNCION
    | LLAMADA
    | IMPRESION
    | cuerpo CONDICIONALES
    | cuerpo DECLARACION 
    | cuerpo ASIGNACION 
    | cuerpo RETORNO
    | cuerpo METODO
    | cuerpo FUNCION
    | cuerpo LLAMADA
    | cuerpo IMPRESION
;

LLAMADA::= ejecutar id:idd abrir_par cerrar_par puntoComa
            {:
                txtPython+=tab()+String.valueOf(idd)+"()\n";
                txtGo+= tab()+String.valueOf(idd)+"()\n";
            :}
    | ejecutar id:idd abrir_par LEJC cerrar_par puntoComa
    {:
        txtPython+= tab()+ String.valueOf(idd)+"("+aux2+")\n";
        txtGo+=tab()+String.valueOf(idd)+"("+aux2G+")\n";
        auxP="";
        auxC="";
        aux2="";
        aux2G="";
    :}
;

METODO::= metodo id:idd 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+"():\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"(){\n";
        contTPY+=1; 
        auxP="";
        auxC="";
    :} INSTRUCCIONES Finmetodo 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
        | metodo id:idd con_parametros abrir_par LISTAP cerrar_par 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+"("+aux2+"):\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"("+aux2G+"){\n";
        contTPY+=1; 
        aux2="";
        aux2G="";
    :} INSTRUCCIONES Finmetodo 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
;

FUNCION::= funcion id:idd TIPODATO:tdd 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+":\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"()"+String.valueOf(tdd)+"{\n";
        contTPY+=1; 
        auxP="";
        auxC="";
    :} INSTRUCCIONES Finfuncion 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
        | funcion id:idd TIPODATO:tdd con_parametros abrir_par LISTAP cerrar_par 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+"("+aux2+"):\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"("+aux2G+")"+String.valueOf(tdd)+"{\n";
        contTPY+=1; 
        aux2="";
        aux2G="";
    :} INSTRUCCIONES  Finfuncion 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
;

IMPRESION::= imprimir CONDICION:b puntoComa 
    {:
        txtPython+=tab()+"print("+auxP+")\n";
        txtGo+=tab()+"fmt.Print("+auxC+")\n";
        auxP="";
        auxC="";
    :}
        | imprimir_nl CONDICION:b puntoComa 
    {:
        txtPython+=tab()+"print("+auxP+",\"\\n\")\n";
        txtGo+=tab()+"fmt.Println("+auxC+")\n";
        auxP="";
        auxC="";
    :}
;

DECLARACION::= Ringresar 
            {:
                txtPython+=tab();
                txtGo+=tab()+"var ";
            :} LISTA Rcomo TIPODATO:ttd {:auxTP+=ttd;:} RCon_valor CONDICION:b puntoComa
            {:
                txtPython+=aux2;
                txtGo+=aux2;

                aux2="";
                txtPython+=" = ";
                txtGo+=" "+auxTP+" = ";
                auxTP="";
           
                for(int i = 0 ; i <= cont1; i = i + 1)
                {
                    if(i==0){
                        tmp+=auxP;
                        tmpG+=auxC;
                    }
                    else{
                        tmp+= "," + auxP;
                        tmpG+= ","+ auxC;
                    }

                };
                txtPython+= tmp+"\n";
                txtGo+= tmpG+"\n"; 
                auxP="";
                auxC="";
                tmp="";
                tmpG="";
                cont1=0;
            :}
; 

ASIGNACION::= LISTA asignacion CONDICION:b puntoComa
            {:
                txtPython+= tab()+aux2;
                txtGo+= tab()+aux2;
                aux2="";
                txtPython+=" = ";
                txtGo+=" = ";

                for(int i = 0 ; i <= cont1; i = i + 1)
                {
                    if(i==0){
                        tmp+=auxP;
                        tmpG+=auxC;
                    }
                    else{
                        tmp+= "," + auxP;
                        tmpG+= ","+ auxC;
                    }

                };
                txtPython+= tmp+"\n";
                txtGo+=tmpG+"\n";
                auxP="";
                auxC="";
                tmp="";
                tmpG="";
                cont1=0;
            :}

;

//Lista de parametros
LISTAP::= id:idd TIPODATO:tdd 
    {:
        aux2+=String.valueOf(idd);
        aux2G+= String.valueOf(idd)+" "+String.valueOf(tdd);
    :} 
        | LISTAP Coma id:idd  TIPODATO:tdd 
    {:
        aux2+=","+String.valueOf(idd);
        aux2G+=","+String.valueOf(idd)+" "+String.valueOf(tdd);
    :}
;

//Lista de id (declaracion, asignacion)
LISTA::= id:idd 
    {:
        aux2+=idd.toString();
    :}
        | LISTA Coma id:idd 
    {:
        aux2+=","+idd.toString();
        cont1=cont1+1;
    :}
;

//Lista para llamadas
LEJC::= CONDICION:b  
    {:
        aux2+=auxP;
        aux2G+=auxC;
        auxC="";
        auxP="";
    :}
        | LEJC Coma CONDICION:b 
    {:
        aux2+=","+auxP;
        aux2G+=","+auxC;
        auxC="";
        auxP="";
    :}
;

CONDICIONALES::= IF
                | SEGUN
                | PARA
                | MIENTRAS
                | REPETIR
;

IF::= condSi CONDICION:b 
    {:
        txtPython+=tab()+"if "+auxP+":\n";
        txtGo+=tab()+"if "+auxC+" {\n";
        contTPY+=1; auxP="";auxC="";
    :} 
    auxFS
;

auxFS::= entonces INSTRUCCIONES finSi 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :}
    | entonces INSTRUCCIONES contrario  
    {:
        contTPY-=1;
        txtPython+=tab()+"else:\n";
        txtGo+=tab()+"} else {\n";
        contTPY+=1;
    :} 
    INSTRUCCIONES finSi 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} 
    | entonces INSTRUCCIONES BLOQUE finSi 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} 
  
;

BLOQUE::= OSi CONDICION:b entonces 
    {:
        contTPY-=1; 
        txtPython+=tab()+"elif "+auxP+":\n";
        txtGo+= tab()+"}else if "+auxC+" {\n";
        contTPY+=1;
        auxP="";
        auxC="";
    :}  INSTRUCCIONES
        | BLOQUE OSi CONDICION:b entonces 
    {:
        contTPY-=1; 
        txtPython+=tab()+"elif "+auxP+":\n";
        txtGo+=tab()+"}else if "+auxC+" {\n";
        contTPY+=1;
        auxP=""; auxC="";
    :} INSTRUCCIONES
        | BLOQUE contrario 
    {:
        contTPY-=1;
        txtPython+=tab()+"else:\n";
        txtGo+=tab()+" }else {\n";
        contTPY+=1;
        auxP="";
        auxC="";
    :}   INSTRUCCIONES
;

PARA::= para id:idd asignacion CONDICION:b 
    {:
        auxID=String.valueOf(idd);
        txtPython+=tab()+"for "+auxID+" in range("+auxP; 
        txtGo+=tab()+"for "+auxID+" := "+auxC+";";
        auxP="";
        auxC="";
    :} 
    hasta CONDICION:c 
    {:
        tmpPARA=auxP;
        tmpPARAG=auxC;
        contTPY+=1; 
        auxP="";
        auxC="";
        
    :}
    BLOQUEPARA
     
;

BLOQUEPARA::= hacer
    {:
        txtPython+=","+tmpPARA+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"++ {\n";
        tmpPARA ="";tmpPARAG="";auxID="";

    :} INSTRUCCIONES finPara  
    {: 
        contTPY-=1; txtGo+=tab()+"}\n";
    :}
    | incremento CONDICION hacer 
    {:
        txtPython+=","+tmpPARA+","+auxP+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"+= "+auxC+"{\n";
        tmpPARA ="";tmpPARAG="";auxID="";auxP="";auxC="";
    :} INSTRUCCIONES finPara 
    {: 
        contTPY-=1; txtGo+=tab()+"}\n";
    :}
    | hacer finPara 
    {:
        txtPython+=","+tmpPARA+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"++ {\n";
        tmpPARA ="";tmpPARAG="";auxID="";
        contTPY-=1; txtGo+=tab()+"}\n";
    :} 
    | incremento CONDICION hacer finPara 
    {:
        txtPython+=","+tmpPARA+","+auxP+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"+= "+auxC+"{\n";
        tmpPARA ="";tmpPARAG="";auxID="";auxP="";auxC="";
        contTPY-=1; txtGo+=tab()+"}\n";
    :}
;

MIENTRAS::= mientras CONDICION:b hacer 
    {:
        txtPython+=tab()+"while "+auxP+":\n";
        txtGo+=tab()+"for true {\n"; contTPY+=1; 
        txtGo+=tab()+"if !("+auxC+"){\n";  contTPY+=1;
        txtGo+=tab()+"break\n";  contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} INSTRUCCIONES finMientras 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
        | mientras CONDICION:b hacer 
    {:
        txtPython+=tab()+"while "+auxP+":\n";
        txtGo+=tab()+"for true {\n"; contTPY+=1; 
        txtGo+=tab()+"if !("+auxC+"){\n";  contTPY+=1;
        txtGo+=tab()+"break\n";  contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} finMientras 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
;

REPETIR::= repetir 
    {:
        txtPython+=tab()+"while "+auxP+"\n";
        txtGo+= tab()+"for true {\n";
        contTPY+=1;
    :} INSTRUCCIONES hastaQue CONDICION:b 
    {:
        txtPython+=tab()+"if "+auxP+" == False:\n";
        txtGo+=tab()+"if ("+auxC+"){\n"; contTPY+=1;
        txtPython+=tab()+"break\n";
        txtGo+=tab()+"break}\n";
        contTPY-=2; 
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :}
        | repetir hastaQue CONDICION:b 
    {:
        txtPython+=tab()+"while "+auxP+"\n";
        txtGo+= tab()+"for true {\n"; contTPY+=1;
        txtPython+=tab()+"if "+auxP+" == False:\n";
        txtGo+=tab()+"if ("+auxC+"){\n"; contTPY+=1;
        txtPython+=tab()+"break\n"; 
        txtGo+=tab()+"break}\n";
        contTPY-=2; 
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :}
;

RETORNO::= retornar CONDICION:b puntoComa 
    {:
        txtPython+=tab()+"return "+auxP+"\n";
        txtGo+=tab()+"return "+auxC+"\n";
        auxP="";auxC="";
    :}
;

SEGUN::= segun CONDICION:b hacer 
    {:
        tmpPS+=auxP;
        txtGo+=tab()+"switch "+auxC+" {\n";
        auxP="";auxC="";
    :} CASE finSegun 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        tmpPS="";
    :}
;

CASE::= aitr CONDICION:c citr entonces 
    {:
        txtPython+=tab()+"if "+tmpPS+"=="+auxP+":\n";
        txtGo+= tab()+"case "+auxC+":\n";
        contTPY+=1;
        auxP="";auxC="";
    :} INSTRUCCIONES 
        | CASE contrario entonces 
    {:
        contTPY-=1;
        txtPython+=tab()+"else:\n";
        txtGo+= tab()+"default:\n";
        contTPY+=1;
    :} INSTRUCCIONES
        | CASE aitr CONDICION:c citr entonces 
    {:
        contTPY-=1; 
        txtPython+=tab()+"elif "+tmpPS+"=="+auxP+":\n";
        txtGo+= tab()+"case "+auxC+":\n";
        contTPY+=1;
        auxP="";auxC="";
    :} INSTRUCCIONES
;

OPERACIONES::= EXPRESION:a 
    {:
        RESULT=a; 
        System.out.println("datoTot:"+a.toString());
        //si empieza con $ es caracter
        if(a.toString().length()>1){
            if((a.toString().charAt(1)=='$')){
                //obtener numero
                cA+= a.toString().replace("'","").replace("$","").replace("{","").replace("}","");
                c = Integer.parseInt(cA);
                //verificar numero sino espacion en blanco
                if((c>=65 && c<=90)||(c>=97 && c<=122)){
                    char convertedChar = (char)c;
                    auxP+= "'"+String.valueOf(convertedChar)+"'";
                    auxC+= "'"+String.valueOf(convertedChar)+"'";
                    cA="";
                }
                else{
                    auxP+= "\" \"";
                    auxC+= "\" \"";
                    cA="";
                }
            }
            else if(a.toString().toLowerCase().equals("verdadero")){
                auxP+= "True";
                auxC+= "true";
            }
            else if(a.toString().toLowerCase().equals("falso")){
                auxP+= "False";
                auxC+= "false";
            }
            else{
                auxP+= a.toString();
                auxC+= a.toString();
            }
        }
        else{
            auxP+= a.toString();
            auxC+= a.toString();
        }
    :}
;

EXPRESION::= EXPRESION:a mas OP1:b          {:RESULT = sumaO(a,b);:} 
    | EXPRESION:a resta OP1:b               {:RESULT = restaO(a,b);:} 
    | OP1:a                                 {:RESULT =a;:}
;
    
OP1::= OP1:a mult OP2:b     {:RESULT = multi(a,b);:} 
      | OP1:a div  OP2:b    {:RESULT = divs(a,b);:} 
      | OP1:a Rmod OP2:b    {:RESULT = modulo(a,b);:} 
      | OP2:a               {:RESULT =a;:}
;

OP2::= OP2:a Rpotencia abrir_cor OP3:b cerrar_cor {:RESULT = potencia(a,b);:}
    |  OP3:a {: RESULT = a; :}
;                 

OP3::= abrir_par {:auxP+="("; auxC+="(";:} OPERACIONES:a cerrar_par {:RESULT = a; auxP+=")"; auxC+=")";:}
    |digitoEntero:a       {:RESULT = a;:} 
    | digitoDecimal:a       {:RESULT = a;:} 
    | id:a                  {:RESULT = a;:} 
    | Cadena:a              {:RESULT = a;:} 
    | caracter:a            {:RESULT = a;:} 
    | Rtrue:a               {:RESULT = a;:} 
    | Rfalse:a              {:RESULT = a;:} 
    | caracterAS:a          {:RESULT = a;:}
    
;

CONDICION::= OPERACIONES
    | OPERACIONES OP:opr {:auxP+=opr; auxC+=opr;:} OPERACIONES
    | CONDICION OPL:oopl 
    {:
        if(oopl.toString().equals("or")){
            auxP+=" or ";
            auxC+=" || ";
        }

        if(oopl.toString().equals("and")){
            auxP+=" and ";
            auxC+=" && ";
        }

        if(oopl.toString().equals("not")){
            auxP+=" not ";
            auxC+=" ! ";
        }
    :} 
    OPERACIONES OP:opr {:auxP+=opr; auxC+=opr;:} OPERACIONES
;

OP::= mayor:oop {:RESULT=">";:}
    | menor:oop {:RESULT="<";:}
    | mayorIgual:oop {:RESULT=">=";:}
    | menorIgual:oop {:RESULT="<=";:}
    | igual:oop {:RESULT="==";:}
    | diferente:oop {:RESULT="!=";:}
;

OPL::= or:opl {:RESULT=opl;:}
    | and: opl {:RESULT=opl;:}
    | not: opl {:RESULT=opl;:}
;

INSTRUCCIONES::= DECLARACION
    | ASIGNACION
    | CONDICIONALES
    | LLAMADA
    | IMPRESION
    | RETORNO
    | INSTRUCCIONES RETORNO
    | INSTRUCCIONES DECLARACION 
    | INSTRUCCIONES ASIGNACION
    | INSTRUCCIONES CONDICIONALES
    | INSTRUCCIONES LLAMADA
    | INSTRUCCIONES IMPRESION
;

TIPODATO::= Rnumero:td {:RESULT="float64";:}
            | Rcadena:td {:RESULT="string";:}
            | Rboolean:td {:RESULT="bool";:}
            | Rcaracter:td {:RESULT="byte";:}
;
