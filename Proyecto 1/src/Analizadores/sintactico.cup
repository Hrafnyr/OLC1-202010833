package Analizadores;
import java_cup.runtime.Symbol;
import proyecto_olc1.Nodo;
import proyecto_olc1.arbolSintactico;

parser code 
{:
    //Variables para el Arbol sintactico
    proyecto_olc1.arbolSintactico arbolAux = proyecto_olc1.interfaz.arbol;
    proyecto_olc1.Nodo nodoAux = proyecto_olc1.interfaz.nodo;

    int v1,v2 = 0;
    int contLL,contCL = 0;
    String crp = "cuerpo";
    String ins = "INSTRUCCIONES";

    public static String txtPython = ""; //Variable que guarda el código python
    String auxP = ""; //Guarda condicion/expresion
    String aux2=""; //Guarda informacion de lista parametros, nombres y expresiones/condiciones
    String tmpPS = ""; //Guarda condicion del switch case
    String tmp = "";   // Guarda lista de resultados asignacion/declaracion
    String tmpPARA =""; //Guarda condicion hasta(condicion) del ciclo para
    int cont1 = 0; //contador de nombres asignacion/declaracion

    int contTPY = 0; //contador de tabulacion
    
    public static String txtGo = ""; //Variable que guarda el código Golang
    String auxTP = ""; //guarda el tipo de dato
    String auxC = "";
    String aux2G = "";
    String tmpG="";
    String auxID="";
    String tmpPARAG="";
    String imps = ""; //guarda bloque de importaciones
    int flag = 0; //verificador para cierre de llave main
    int flag2 = 0;

    //caracter ascii
    String cA = ""; //guarda el valor del token caracter Ascci
    int c = 0; //guarda el valor del caracter asccii

    //Metodo para calcular la identación correcta python
    public String tab(){
        String tab = "";
        for(int i = 0; i < (contTPY*4); i++) {
            tab+=" ";

        }
       
        return tab;
    }

    //Método al que se llama automáticamente ante algún error sintactico. 
    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
            claseErrores datos = new claseErrores(String.valueOf(s.value), "Error sintáctico", "No se esperaba este componente:",s.left,s.right);
            Analizador_Lexico.TError.add(datos);
    } 
    
    //Método al que se llama en el momento en que ya no es posible una recuperación de errores. 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
            claseErrores datos = new claseErrores("Null", "Error sintáctico", "Error irrecuperable", s.left,s.right);
            Analizador_Lexico.TError.add(datos);
    }
:} 

action code
{:
    String sumaO(Object v1, Object v2){
        auxP+= " "+v1.toString() + " + " + v2.toString();
        auxC+= " "+v1.toString() + " + " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
    
    String restaO(Object v1, Object v2){
        auxP+= " "+v1.toString() + " - " + v2.toString();
        auxC+= " "+v1.toString() + " - " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        flag2=0;
        return "";
    }

    String multi(Object v1, Object v2){
        auxP+= " "+v1.toString() + " * " + v2.toString();
        auxC+= " "+v1.toString() + " * " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }

    String divs(Object v1, Object v2){

        auxP+= " "+v1.toString() + " / " + v2.toString();
        auxC+= " "+v1.toString() + " / " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
    
    String modulo(Object v1, Object v2){

        auxP+= " "+v1.toString() + " % " + v2.toString();
        auxC+= " "+v1.toString() + " % " + v2.toString();
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
    
    String potencia(Object v1, Object v2){

        auxP+= " "+v1.toString() + " ** " + v2.toString();
        auxC+= " math.Pow(float64("+v1.toString() + "),float64(" + v2.toString()+"))";
        System.out.println("dato:"+v1.toString()+"," + v2.toString());
        return "";
    }
:}

//Terminales
terminal Cadena;
terminal digitoEntero;
terminal digitoDecimal;
terminal caracter;
terminal caracterAS;
terminal Rtrue;
terminal Rfalse;
terminal abrir_cor;
terminal cerrar_cor;
terminal Rnumero;
terminal Rcadena;
terminal Rboolean;
terminal Rcaracter;
terminal mas;
terminal resta;
terminal mult;
terminal div;
terminal Rpotencia;
terminal Rmod;
terminal abrir_par;
terminal cerrar_par;
terminal aitr;
terminal citr;
terminal puntoComa;
terminal Coma;
terminal mayor;
terminal menor;
terminal mayorIgual;
terminal menorIgual;
terminal igual;
terminal diferente;
terminal or;
terminal and;
terminal not;
terminal inicio;
terminal fin;
terminal Ringresar;
terminal id;
terminal Rcomo;
terminal RCon_valor;
terminal asignacion;
terminal condSi;
terminal contrario;
terminal finSi;
terminal OSi;
terminal segun;
terminal hacer;
terminal entonces;
terminal finSegun;
terminal para;
terminal hasta;
terminal incremento;
terminal finPara;
terminal mientras;
terminal finMientras;
terminal repetir;
terminal hastaQue;
terminal retornar;
terminal metodo;
terminal Finmetodo;
terminal con_parametros;
terminal funcion;
terminal Finfuncion;
terminal ejecutar;
terminal imprimir;
terminal imprimir_nl;


//No terminales
non terminal cuerpo,INICIO, ASIGNACION,DECLARACION, EXPRESION, TIPODATO;
non terminal LISTA, CONDICIONALES;
non terminal IF, CONDICION, INSTRUCCIONES, BLOQUE;
non terminal SEGUN, CASE;
non terminal PARA,BLOQUEPARA;
non terminal MIENTRAS,REPETIR;
non terminal RETORNO, IMPRESION;
non terminal METODO, LISTAP, FUNCION, LLAMADA;
non terminal OP, OPL;
non terminal LEJC;
non terminal auxFS;
non terminal OP1, OP2,OP3;
non terminal OPERACIONES;

//gramaticas
start with INICIO;

INICIO::= inicio
    {: 
        //arbol
        arbolAux.InsertarRecursivo(nodoAux,"Rinicio","Global");
        arbolAux.InsertarRecursivo(nodoAux,"inicio","inicio");
        arbolAux.InsertarRecursivo(nodoAux,"cuerpo","Global");
        arbolAux.InsertarRecursivo(nodoAux,"Rfin","Global");

        txtPython+=tab()+"def main():\n";
        imps+= "import (\n\"fmt\"\n\"math\"\n)\n";
        txtGo+=tab()+"package main\n"+tab()+imps+"func main(){\n";
        contTPY+=1;
    :} cuerpo:crp fin
    {:
        arbolAux.InsertarRecursivo(nodoAux,"fin","Rfin");

        txtPython+="if __name__ == '__main__':\n    main()";
        
        if(flag==0){
            txtGo+="}";
        }

        contTPY-=1;
        imps = "";
        System.out.println(txtPython);
        System.out.println(txtGo);
    :}
    | error fin {:System.out.println("Falta inicio");:}
;

cuerpo::= DECLARACION
    | ASIGNACION
    | CONDICIONALES
    | RETORNO               
    | METODO
    | FUNCION
    | LLAMADA       
    | IMPRESION 
    | cuerpo CONDICIONALES 
    | cuerpo DECLARACION    
    | cuerpo ASIGNACION     
    | cuerpo RETORNO        
    | cuerpo METODO         
    | cuerpo FUNCION        
    | cuerpo LLAMADA        
    | cuerpo IMPRESION      
;

LLAMADA::= ejecutar id:idd abrir_par cerrar_par puntoComa
            {:  
                                
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-LLAMADA",crp);

                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-Rejecutar",String.valueOf(contLL)+"-LLAMADA");
                arbolAux.InsertarRecursivo(nodoAux,"ejecutar",String.valueOf(contLL)+"-ejecutar");

                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-id",String.valueOf(contLL)+"-LLAMADA");
                arbolAux.InsertarRecursivo(nodoAux,idd.toString(),String.valueOf(contLL)+"-id");

                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-abrir_par",String.valueOf(contLL)+"-LLAMADA");
                arbolAux.InsertarRecursivo(nodoAux,"(",String.valueOf(contLL)+"-abrir_par");
                
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-cerrar_par",String.valueOf(contLL)+"-LLAMADA");
                arbolAux.InsertarRecursivo(nodoAux,")",String.valueOf(contLL)+"-cerrar_par");

                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-puntoComa",String.valueOf(contLL)+"-LLAMADA");
                arbolAux.InsertarRecursivo(nodoAux,";",String.valueOf(contLL)+"-puntoComa");
    
                txtPython+=tab()+String.valueOf(idd)+"()\n";
                txtGo+= tab()+String.valueOf(idd)+"()\n";
                contLL++;
            :}
    | ejecutar id:idd abrir_par {:
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-LLAMADA",crp);

        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-Rejecutar",String.valueOf(contLL)+"-LLAMADA");
        arbolAux.InsertarRecursivo(nodoAux,"ejecutar",String.valueOf(contLL)+"-ejecutar");

        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-id",String.valueOf(contLL)+"-LLAMADA");
        arbolAux.InsertarRecursivo(nodoAux,idd.toString(),String.valueOf(contLL)+"-id");

        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-abrir_par",String.valueOf(contLL)+"-LLAMADA");
        arbolAux.InsertarRecursivo(nodoAux,"(",String.valueOf(contLL)+"-abrir_par");

        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-LEJC",String.valueOf(contLL)+"-LLAMADA");

    :} LEJC cerrar_par puntoComa
    {:
        
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-cerrar_par",String.valueOf(contLL)+"-LLAMADA");
        arbolAux.InsertarRecursivo(nodoAux,")",String.valueOf(contLL)+"-cerrar_par");

        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-puntoComa",String.valueOf(contLL)+"-LLAMADA");
        arbolAux.InsertarRecursivo(nodoAux,";",String.valueOf(contLL)+"-puntoComa");
        
       

        txtPython+= tab()+ String.valueOf(idd)+"("+aux2+")\n";
        txtGo+=tab()+String.valueOf(idd)+"("+aux2G+")\n";
        contLL++;
        auxP="";
        auxC="";
        aux2="";
        aux2G="";
    :}
;

//FALTA ARBOL
METODO::= metodo id:idd 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+"():\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"(){\n";
        contTPY+=1; 
        auxP="";
        auxC="";
    :} INSTRUCCIONES Finmetodo 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
        | metodo id:idd con_parametros abrir_par LISTAP cerrar_par 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+"("+aux2+"):\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"("+aux2G+"){\n";
        contTPY+=1; 
        aux2="";
        aux2G="";
    :} INSTRUCCIONES Finmetodo 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
;

//FALTA ARBOL
FUNCION::= funcion id:idd TIPODATO:tdd 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+":\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"()"+String.valueOf(tdd)+"{\n";
        contTPY+=1; 
        auxP="";
        auxC="";
    :} INSTRUCCIONES Finfuncion 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
        | funcion id:idd TIPODATO:tdd con_parametros abrir_par LISTAP cerrar_par 
    {:
        txtPython+=tab()+"def "+String.valueOf(idd)+"("+aux2+"):\n";
        flag=1;
        txtGo+="}\n";
        txtGo+="func "+String.valueOf(idd)+"("+aux2G+")"+String.valueOf(tdd)+"{\n";
        contTPY+=1; 
        aux2="";
        aux2G="";
    :} INSTRUCCIONES  Finfuncion 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
;

IMPRESION::= imprimir 
    {:
    arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-IMPRESION",crp);
    arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-Rimprimir",String.valueOf(contLL)+"-IMPRESION");
    arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-imprimir",String.valueOf(contLL)+"-imprimir");
    arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-CONDICION",String.valueOf(contLL)+"-IMPRESION");
    arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-puntoComa",String.valueOf(contLL)+"-IMPRESION");
    arbolAux.InsertarRecursivo(nodoAux,";",String.valueOf(contLL)+"-puntoComa");
    :}
    CONDICION:b puntoComa 
    
    {:       

        txtPython+=tab()+"print("+auxP+")\n";
        txtGo+=tab()+"fmt.Print("+auxC+")\n";
        contLL++;
        contCL++;
        auxP="";
        auxC="";
    :}
        | imprimir_nl 
    {:
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-IMPRESION",crp);
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-Rimprimir_nl",String.valueOf(contLL)+"-IMPRESION");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-imprimir_nl",String.valueOf(contLL)+"-imprimir_nl");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-CONDICION",String.valueOf(contLL)+"-IMPRESION");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-puntoComa",String.valueOf(contLL)+"-IMPRESION");
        arbolAux.InsertarRecursivo(nodoAux,";",String.valueOf(contLL)+"-puntoComa");
    :} 
        CONDICION:b puntoComa 
    {:
        txtPython+=tab()+"print("+auxP+",\"\\n\")\n";
        txtGo+=tab()+"fmt.Println("+auxC+")\n";
        contLL++;
        contCL++;
        auxP="";
        auxC="";
    :}
;

DECLARACION::= Ringresar 
            {:
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-DECLARACION",crp);
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-Ringresar",String.valueOf(contLL)+"-DECLARACION");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-ingresar",String.valueOf(contLL)+"-Ringresar");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-LISTA",String.valueOf(contLL)+"-DECLARACION");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-Rcomo",String.valueOf(contLL)+"-DECLARACION");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-como",String.valueOf(contLL)+"-Rcomo");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-TIPODATO",String.valueOf(contLL)+"-DECLARACION");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-RCon_valor",String.valueOf(contLL)+"-DECLARACION");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-con_valor",String.valueOf(contLL)+"-RCon_valor");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-CONDICION",String.valueOf(contLL)+"-DECLARACION");
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-puntoComa",String.valueOf(contLL)+"-DECLARACION");
                arbolAux.InsertarRecursivo(nodoAux,";",String.valueOf(contLL)+"-puntoComa");

                txtPython+=tab();
                txtGo+=tab()+"var ";
            :} LISTA Rcomo TIPODATO:ttd {:auxTP+=ttd;:} RCon_valor CONDICION:b puntoComa
            {:
                contLL++;
                contCL++;

                txtPython+=aux2;
                txtGo+=aux2;

                aux2="";
                txtPython+=" = ";
                txtGo+=" "+auxTP+" = ";
                auxTP="";
           
                for(int i = 0 ; i <= cont1; i = i + 1)
                {
                    if(i==0){
                        tmp+=auxP;
                        tmpG+=auxC;
                    }
                    else{
                        tmp+= "," + auxP;
                        tmpG+= ","+ auxC;
                    }

                };
                txtPython+= tmp+"\n";
                txtGo+= tmpG+"\n"; 
                auxP="";
                auxC="";
                tmp="";
                tmpG="";
                cont1=0;
            :}
; 

ASIGNACION::= 
    {:
        //arbol
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-ASIGNACION",crp);
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-LISTA",String.valueOf(contLL)+"-ASIGNACION");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-Rasignacion",String.valueOf(contLL)+"-ASIGNACION");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"- ->",String.valueOf(contLL)+"-Rasignacion");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-CONDICION",String.valueOf(contLL)+"-ASIGNACION");

    :} LISTA asignacion CONDICION:b puntoComa
            {:
                arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-puntoComa",String.valueOf(contLL)+"-ASIGNACION");
                arbolAux.InsertarRecursivo(nodoAux,";",String.valueOf(contLL)+"-puntoComa");

                txtPython+= tab()+aux2;
                txtGo+= tab()+aux2;
                aux2="";
                txtPython+=" = ";
                txtGo+=" = ";

                for(int i = 0 ; i <= cont1; i = i + 1)
                {
                    if(i==0){
                        tmp+=auxP;
                        tmpG+=auxC;
                    }
                    else{
                        tmp+= "," + auxP;
                        tmpG+= ","+ auxC;
                    }

                };
                txtPython+= tmp+"\n";
                txtGo+=tmpG+"\n";
                auxP="";
                auxC="";
                tmp="";
                tmpG="";
                cont1=0;
                contLL++;
                contCL++;
            :}

;

//Lista de parametros
LISTAP::= id:idd TIPODATO:tdd 
    {:
        aux2+=String.valueOf(idd);
        aux2G+= String.valueOf(idd)+" "+String.valueOf(tdd);
    :} 
        | LISTAP Coma id:idd  TIPODATO:tdd 
    {:
        aux2+=","+String.valueOf(idd);
        aux2G+=","+String.valueOf(idd)+" "+String.valueOf(tdd);
    :}
;

//Lista de id (declaracion, asignacion)
LISTA::= id:idd 
    {:
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-idd",String.valueOf(contLL)+"-LISTA");
        arbolAux.InsertarRecursivo(nodoAux,idd.toString(),String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-idd");
        contCL++;
        aux2+=idd.toString();
    :}
        | LISTA Coma  id:idd 
    {:
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-Coma",String.valueOf(contLL)+"-LISTA");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"- , ",String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-Coma");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-idd",String.valueOf(contLL)+"-LISTA");
        arbolAux.InsertarRecursivo(nodoAux,idd.toString(),String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-idd");
        
        contCL++;
        aux2+=","+idd.toString();
        cont1=cont1+1;
    :}
;

//Lista para llamadas
LEJC::= CONDICION:b  
    {:
        
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-CONDICION",String.valueOf(contLL)+"-LEJC");

        contCL++;
        aux2+=auxP;
        aux2G+=auxC;
        auxC="";
        auxP="";
    :}
        | LEJC Coma 
    {:
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-Coma",String.valueOf(contLL)+"-LEJC");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"- , ",String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-Coma");
        arbolAux.InsertarRecursivo(nodoAux,String.valueOf(contLL)+"-"+String.valueOf(contCL)+"-CONDICION",String.valueOf(contLL)+"-LEJC");
    :} CONDICION:b 
    {:
        aux2+=","+auxP;
        aux2G+=","+auxC;
        contCL++;
        auxC="";
        auxP="";
    :}
;

CONDICIONALES::= IF
                | SEGUN
                | PARA
                | MIENTRAS
                | REPETIR
;

IF::= condSi CONDICION:b 
    {:
        txtPython+=tab()+"if "+auxP+":\n";
        txtGo+=tab()+"if "+auxC+" {\n";
        contTPY+=1; auxP="";auxC="";
    :} 
    auxFS
;

auxFS::= entonces INSTRUCCIONES finSi 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :}
    | entonces INSTRUCCIONES contrario  
    {:
        contTPY-=1;
        txtPython+=tab()+"else:\n";
        txtGo+=tab()+"} else {\n";
        contTPY+=1;
    :} 
    INSTRUCCIONES finSi 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} 
    | entonces INSTRUCCIONES BLOQUE finSi 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} 
  
;

BLOQUE::= OSi CONDICION:b entonces 
    {:
        contTPY-=1; 
        txtPython+=tab()+"elif "+auxP+":\n";
        txtGo+= tab()+"}else if "+auxC+" {\n";
        contTPY+=1;
        auxP="";
        auxC="";
    :}  INSTRUCCIONES
        | BLOQUE OSi CONDICION:b entonces 
    {:
        contTPY-=1; 
        txtPython+=tab()+"elif "+auxP+":\n";
        txtGo+=tab()+"}else if "+auxC+" {\n";
        contTPY+=1;
        auxP=""; auxC="";
    :} INSTRUCCIONES
        | BLOQUE contrario 
    {:
        contTPY-=1;
        txtPython+=tab()+"else:\n";
        txtGo+=tab()+" }else {\n";
        contTPY+=1;
        auxP="";
        auxC="";
    :}   INSTRUCCIONES
;

PARA::= para id:idd asignacion CONDICION:b 
    {:
        auxID=String.valueOf(idd);
        txtPython+=tab()+"for "+auxID+" in range("+auxP; 
        txtGo+=tab()+"for "+auxID+" := "+auxC+";";
        auxP="";
        auxC="";
    :} 
    hasta CONDICION:c 
    {:
        tmpPARA=auxP;
        tmpPARAG=auxC;
        contTPY+=1; 
        auxP="";
        auxC="";
        
    :}
    BLOQUEPARA
     
;

BLOQUEPARA::= hacer
    {:
        txtPython+=","+tmpPARA+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"++ {\n";
        tmpPARA ="";tmpPARAG="";auxID="";

    :} INSTRUCCIONES finPara  
    {: 
        contTPY-=1; txtGo+=tab()+"}\n";
    :}
    | incremento CONDICION hacer 
    {:
        txtPython+=","+tmpPARA+","+auxP+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"+= "+auxC+"{\n";
        tmpPARA ="";tmpPARAG="";auxID="";auxP="";auxC="";
    :} INSTRUCCIONES finPara 
    {: 
        contTPY-=1; txtGo+=tab()+"}\n";
    :}
    | hacer finPara 
    {:
        txtPython+=","+tmpPARA+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"++ {\n";
        tmpPARA ="";tmpPARAG="";auxID="";
        contTPY-=1; txtGo+=tab()+"}\n";
    :} 
    | incremento CONDICION hacer finPara 
    {:
        txtPython+=","+tmpPARA+","+auxP+"):\n";
        txtGo+= " "+tmpPARAG+";"+auxID+"+= "+auxC+"{\n";
        tmpPARA ="";tmpPARAG="";auxID="";auxP="";auxC="";
        contTPY-=1; txtGo+=tab()+"}\n";
    :}
;

MIENTRAS::= mientras CONDICION:b hacer 
    {:
        txtPython+=tab()+"while "+auxP+":\n";
        txtGo+=tab()+"for true {\n"; contTPY+=1; 
        txtGo+=tab()+"if !("+auxC+"){\n";  contTPY+=1;
        txtGo+=tab()+"break\n";  contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} INSTRUCCIONES finMientras 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
        | mientras CONDICION:b hacer 
    {:
        txtPython+=tab()+"while "+auxP+":\n";
        txtGo+=tab()+"for true {\n"; contTPY+=1; 
        txtGo+=tab()+"if !("+auxC+"){\n";  contTPY+=1;
        txtGo+=tab()+"break\n";  contTPY-=1;
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :} finMientras 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
    :}
;

REPETIR::= repetir 
    {:
        txtPython+=tab()+"while "+auxP+"\n";
        txtGo+= tab()+"for true {\n";
        contTPY+=1;
    :} INSTRUCCIONES hastaQue CONDICION:b 
    {:
        txtPython+=tab()+"if "+auxP+" == False:\n";
        txtGo+=tab()+"if ("+auxC+"){\n"; contTPY+=1;
        txtPython+=tab()+"break\n";
        txtGo+=tab()+"break}\n";
        contTPY-=2; 
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :}
        | repetir hastaQue CONDICION:b 
    {:
        txtPython+=tab()+"while "+auxP+"\n";
        txtGo+= tab()+"for true {\n"; contTPY+=1;
        txtPython+=tab()+"if "+auxP+" == False:\n";
        txtGo+=tab()+"if ("+auxC+"){\n"; contTPY+=1;
        txtPython+=tab()+"break\n"; 
        txtGo+=tab()+"break}\n";
        contTPY-=2; 
        txtGo+=tab()+"}\n";
        auxP="";auxC="";
    :}
;

RETORNO::= retornar CONDICION:b puntoComa 
    {:
        txtPython+=tab()+"return "+auxP+"\n";
        txtGo+=tab()+"return "+auxC+"\n";
        auxP="";auxC="";
    :}
;

SEGUN::= segun CONDICION:b hacer 
    {:
        tmpPS+=auxP;
        txtGo+=tab()+"switch "+auxC+" {\n";
        auxP="";auxC="";
    :} CASE finSegun 
    {:
        contTPY-=1;
        txtGo+=tab()+"}\n";
        tmpPS="";
    :}
;

CASE::= aitr CONDICION:c citr entonces 
    {:
        txtPython+=tab()+"if "+tmpPS+"=="+auxP+":\n";
        txtGo+= tab()+"case "+auxC+":\n";
        contTPY+=1;
        auxP="";auxC="";
    :} INSTRUCCIONES 
        | CASE contrario entonces 
    {:
        contTPY-=1;
        txtPython+=tab()+"else:\n";
        txtGo+= tab()+"default:\n";
        contTPY+=1;
    :} INSTRUCCIONES
        | CASE aitr CONDICION:c citr entonces 
    {:
        contTPY-=1; 
        txtPython+=tab()+"elif "+tmpPS+"=="+auxP+":\n";
        txtGo+= tab()+"case "+auxC+":\n";
        contTPY+=1;
        auxP="";auxC="";
    :} INSTRUCCIONES
;

OPERACIONES::= EXPRESION:a 
    {:
        RESULT=a; 
        System.out.println("datoTot:"+a.toString());
        //si empieza con $ es caracter
        if(a.toString().length()>1){ 
            if((a.toString().charAt(1)=='$')){
                //obtener numero
                cA+= a.toString().replace("'","").replace("$","").replace("{","").replace("}","");
                c = Integer.parseInt(cA); 
                //verificar numero sino espacion en blanco
                if((c>=65 && c<=90)||(c>=97 && c<=122)){
                    char convertedChar = (char)c; 
                    auxP+= "'"+String.valueOf(convertedChar)+"'";
                    auxC+= "'"+String.valueOf(convertedChar)+"'";
                    cA="";
                }
                else{
                    auxP+= "\" \"";
                    auxC+= "\" \"";
                    cA="";
                }
            }
            else if(a.toString().toLowerCase().equals("verdadero")){
                auxP+= "True";
                auxC+= "true";
            }
            else if(a.toString().toLowerCase().equals("falso")){
                auxP+= "False";
                auxC+= "false";
            }
            else{
                auxP+= a.toString();
                auxC+= a.toString();
            }
        }
        else{
            auxP+= a.toString();
            auxC+= a.toString();
        }
    :}
;

EXPRESION::= EXPRESION:a mas OP1:b          {:RESULT = sumaO(a,b);:} 
    | EXPRESION:a resta OP1:b               {:RESULT = restaO(a,b);:} 
    | OP1:a                                 {:RESULT =a;:}
;
    
OP1::= OP1:a mult OP2:b     {:RESULT = multi(a,b);:} 
      | OP1:a div  OP2:b    {:RESULT = divs(a,b);:} 
      | OP1:a Rmod OP2:b    {:RESULT = modulo(a,b);:} 
      | OP2:a               {:RESULT =a;:}
;

OP2::= OP2:a Rpotencia abrir_cor OP3:b cerrar_cor {:RESULT = potencia(a,b);:}
    |  OP3:a {: RESULT = a; :}
;                 

OP3::= abrir_par            {:auxP+="("; auxC+="(";:} OPERACIONES:a cerrar_par {:RESULT = a; auxP+=")"; auxC+=")";:}
    | digitoEntero:a         {:RESULT = a;:} 
    | digitoDecimal:a       {:RESULT = a;:} 
    | id:a                  {:RESULT = a;:} 
    | Cadena:a              {:RESULT = a;:} 
    | caracter:a            {:RESULT = a;:} 
    | Rtrue:a               {:RESULT = a;:} 
    | Rfalse:a              {:RESULT = a;:} 
    | caracterAS:a          
        {:
            RESULT = a;
            
        :}
    
;

CONDICION::= OPERACIONES
    | OPERACIONES OP:opr {:auxP+=opr; auxC+=opr;:} OPERACIONES
    | CONDICION OPL:oopl 
    {:
        if(oopl.toString().equals("or")){
            auxP+=" or ";
            auxC+=" || ";
        }

        if(oopl.toString().equals("and")){
            auxP+=" and ";
            auxC+=" && ";
        }

        if(oopl.toString().equals("not")){
            auxP+=" not ";
            auxC+=" ! ";
        }
    :} 
    OPERACIONES OP:opr {:auxP+=opr; auxC+=opr;:} OPERACIONES
;

OP::= mayor:oop {:RESULT=">";:}
    | menor:oop {:RESULT="<";:}
    | mayorIgual:oop {:RESULT=">=";:}
    | menorIgual:oop {:RESULT="<=";:}
    | igual:oop {:RESULT="==";:}
    | diferente:oop {:RESULT="!=";:}
;

OPL::= or:opl {:RESULT=opl;:}
    | and: opl {:RESULT=opl;:}
    | not: opl {:RESULT=opl;:}
;

INSTRUCCIONES::= DECLARACION
    | ASIGNACION
    | CONDICIONALES
    | LLAMADA
    | IMPRESION
    | RETORNO
    | INSTRUCCIONES RETORNO
    | INSTRUCCIONES DECLARACION 
    | INSTRUCCIONES ASIGNACION
    | INSTRUCCIONES CONDICIONALES
    | INSTRUCCIONES LLAMADA
    | INSTRUCCIONES IMPRESION
;

TIPODATO::= Rnumero:td {:RESULT="float64";:}
            | Rcadena:td {:RESULT="string";:}
            | Rboolean:td {:RESULT="bool";:}
            | Rcaracter:td {:RESULT="byte";:}
;
